#################################
## gen_dist_metric: generate distance metric 
## Supports Heterogeneous Euclidean-Overlap Metric (heom) and 
## Heterogeneous Value Difference Metric (hvdm); see
## Wilson & Martinez (1997): Improved Heterogeneous Distance Functions, 
## pp.5-6 (heom) or pp.8-9 (hvdm). The calculation of the latter
## uses N2: normalized_ vdm2(x, y) for categorical features.
## data - data frame containing class column, features and optional unique key_id.
## Missing values not yet supported
## colname_target - string with column name of class labels
## use_n_cores - how many cores should be used in calculation (DEFAULT:1)
## n_batches - in how many batches to split the observations (DEFAULT:1)
## dist_type - which distance metric to use (DEFAULT:hvdm)
## Returns a dataframe with key_id_x, key_id_y, class_col_x, class_col_y, dist (distance) 
## for each combination of x and y from key_id. 
## Lyubomir Danov, 2019
#################################

gen_dist_metric <- function(data, colname_target, use_n_cores=1, n_batches=NULL, dist_type=c("hvdm", "heom")) {
  require(dplyr)
  require(tidyr)
  require(tidyselect)
  
  if(missing(data)) {
    stop("data arg not specified")
  }

  if(length(dist_type)!=1){
      warning("more than one distance metric selected; using default hvmd")
      dist_type="hvdm"
  }

  if (missing(colname_target)) {
    stop("colname_target arg not specified")
  } else if (!is.character(colname_target) | length(colname_target)!=1) {
    stop("colname_target arg must be a single string") 
  } else if (!colname_target %in% colnames(data)) {
    stop("colname_target arg must be the name of a column in data") 
  } else if("class_col" %in% colnames(data) & colname_target!="class_col") {
    stop("only colname_target can be named class_col")
  }

  for (k in c("key_id_x", "key_id_y")) {
    if(k %in% colnames(data)) {
      stop(paste0("data cannot contain column named ", k))
    }
  }

  if(!"key_id" %in% colnames(data)) {
    warning("data does not contain key_id key column. It will be automatically generated by mutate(key_id=row_number())")
      data <- data %>% 
        mutate(key_id=row_number())
  }

  if(use_n_cores>1){
    require(parallel)
  }

  if(is.null(n_batches)) {
      n_batches <- use_n_cores
  } else if(n_batches<use_n_cores) {
    warning("n_batches smaller than assigned cores; n_batches overwritten to number of cores")
      n_batches <- use_n_cores
  }
  
  features <- as_data_frame(data) %>%
    rename(class_col = !!sym(colname_target)) %>%
    select(key_id, class_col, everything()) %>%
    mutate_if(is.factor, as.character)
  
  data <- data %>%
    select(one_of(c("key_id", colname_target))) %>%
    rename(class_col = !!sym(colname_target))
  
  # Feature preprocessing
  
  feature_classes <- sapply(features, class)
  feature_types <- feature_classes
  feature_types[feature_types %in% c("numeric", "integer")] <- "n_diff_x"
  feature_types[feature_types %in% c("character")] <- "nvdm"
  feature_types[names(feature_types) %in% c("class_col", "key_id")] <- NA
  
  features_num_names <- names(feature_types)[feature_types=="n_diff_x" & !is.na(feature_types)]
  features_cat_names <- names(feature_types)[feature_types=="nvdm" & !is.na(feature_types)]

# Preprocess numeric features  
  if(length(features_num_names)>0) {
      if (grepl(pattern="hvdm", x=dist_type, ignore.case=TRUE)) {
        range_f <- apply(features[,features_num_names], 2, sd) %>% 
            data_frame(feature_colname=names(.), sd=.) %>%
            mutate(range_n=4*sd) %>%
            select(-sd)
      } else if (grepl(pattern="heom", x=dist_type, ignore.case=TRUE)) {
        range_f <- (apply(features[,features_num_names], 2, max) - apply(features[,features_num_names], 2, min)) %>% 
            data_frame(feature_colname=names(.), range_n=.)
      }  
    
    dist_num <- features %>%
      select(key_id, one_of(features_num_names)) %>% 
      gather(feature_colname, original_x, -key_id) %>%
      left_join(range_f, by="feature_colname") %>%
      mutate(x=original_x/range_n) %>%
      select(-range_n, -original_x)

  } else {
    temp_name <- toString(sample(x = c(letters, LETTERS), 7, replace = T))
    dist_num <- data_frame(key_id=1:nrow(features), feature_colname=temp_name, x=0)
  }
  
# Preprocess categorical features
  if(length(features_cat_names)>0) {
      if(grepl(pattern="hvdm", x=dist_type, ignore.case=TRUE)) {
        feature_cat_enc <- features %>% 
            select(key_id, class_col, one_of(features_cat_names)) %>%
            gather(feature_colname, feature_level, -key_id, -class_col)
            
        dist_cat <- feature_cat_enc %>%
            group_by(feature_colname, feature_level, class_col) %>%
            summarise(N_axc=n()) %>%
            group_by(feature_colname, feature_level) %>%
            mutate(N_ax=sum(N_axc)) %>%
            mutate(P_axc=N_axc/N_ax) %>%
            select(-N_axc, -N_ax) %>%
            rename(class_col_loop=class_col) %>%
            right_join(feature_cat_enc %>% select(-class_col), by = c("feature_colname", "feature_level")) %>%
            ungroup()
      } else if (grepl(pattern="heom", x=dist_type, ignore.case=TRUE)) {
          dist_cat <- features %>% 
            select(key_id, one_of(features_cat_names)) %>%
            gather(feature_colname, feature_level, -key_id)
      }
  } else {
    temp_name <- toString(sample(x = c(letters, LETTERS), 7, replace = T))
    dist_cat <- data_frame(key_id=1:nrow(features), feature_colname=temp_name, class_col_loop=0, feature_level=0, P_axc=0)
  }

  # generate batches
  # each batch calculates the distance between within-batch observations and all others
  # the batch assignment is sorted for speed when filtering
  load_balance <- features %>%
    select(key_id) %>%
    mutate(local_id=sort(rep_len(1:n_batches, length.out = n()))) %>%
    split(., .$local_id)
  
  if(use_n_cores>1){
    
    dist_cl <- parallel::makeCluster(use_n_cores)
    parallel::clusterExport(cl=dist_cl, envir = environment(), varlist = c("dist_num", "dist_cat", "load_balance"))
    parallel::clusterCall(cl = dist_cl, function() library(dplyr))
    on.exit(stopCluster(dist_cl))

    list_dist_total_obs <- parLapplyLB(cl = dist_cl, 
                                       X = 1:n_batches, 
                                       fun = .cl_dist_matrix, 
                                       df_dist_num=dist_num, 
                                       df_dist_cat=dist_cat,
                                       list_load_balance=load_balance,
                                       type=dist_type)
   
  } else {
    
    list_dist_total_obs <- lapply(X = 1:n_batches,  
                                  FUN = .cl_dist_matrix, 
                                  df_dist_num=dist_num, 
                                  df_dist_cat=dist_cat,
                                  list_load_balance=load_balance,
                                  type=dist_type)
    
  }
  
  dist_total_all <- list_dist_total_obs %>%
    bind_rows(.) %>% 
    left_join(data %>% rename(key_id_x=key_id, class_col_x=class_col), by="key_id_x") %>%
    left_join(data %>% rename(key_id_y=key_id, class_col_y=class_col), by="key_id_y") %>%
    arrange(key_id_x, key_id_y) %>%
    as.data.frame(., row_names=NULL) 
  
  return(dist_total_all)
}

.cl_dist_matrix <- function(df_dist_num, df_dist_cat, list_load_balance, type, X) {
    require(dplyr)
    load_balance_local <- list_load_balance[[X]] %>%
      select(key_id)

    # select only this worker's distances
    dist_num_obs <- df_dist_num %>% 
      right_join(load_balance_local, by="key_id") %>%
      rename(key_id_x=key_id) %>%
      left_join(df_dist_num %>% 
                  rename(y=x, key_id_y=key_id), by="feature_colname") %>% 
      mutate(ndiff_a=abs(x-y)) %>% 
      select(key_id_x, key_id_y, feature_colname, ndiff_a) 

    dist_cat_obs <- df_dist_cat %>% 
      right_join(load_balance_local, by="key_id") 
      
    if(grepl(pattern="hvdm", x=type, ignore.case=TRUE)) {
        dist_cat_obs <- dist_cat_obs %>%
            # if any of the features (a) has different class occurences (c), then expand to all observed classes
            # P_axc = (N_axc / N_ax) = (0 / N_ax) = 0
            full_join(df_dist_cat %>% rename(P_ayc=P_axc), by=c("feature_colname", "class_col_loop"), suffix=c("_x", "_y")) %>%
            mutate(P_axc=ifelse(is.na(P_axc), 0, P_axc)) %>%
            mutate(P_ayc=ifelse(is.na(P_ayc), 0, P_ayc)) %>%
            mutate(P_azc=(P_axc-P_ayc)^2) %>%
            group_by(key_id_x, key_id_y, feature_colname) %>%
            summarise(ndiff_a=sqrt(sum(P_azc))) %>%
            ungroup() 
    } else if (grepl(pattern="heom", x=type, ignore.case=TRUE)) {
        dist_cat_obs <- dist_cat_obs %>% 
            full_join(df_dist_cat, by=c("feature_colname"), suffix=c("_x", "_y")) %>%
            mutate(ndiff_a=ifelse(feature_level_x==feature_level_y, 0, 1)) %>%
            select(key_id_x, key_id_y, feature_colname, ndiff_a)
    }

    df_dist_total_worker <- dist_num_obs %>%
      bind_rows(dist_cat_obs) %>%
      group_by(key_id_x, key_id_y) %>%
      summarise(dist=sqrt(sum(ndiff_a^2))) %>%
      ungroup() 

    return(df_dist_total_worker)
  }

# set.seed(1)
# testfr <- data.frame(class=c(rep("maj", 15), rep("min", 5)), 
#             numa=rnorm(20), numb=runif(20), numc=rf(20, 3, 1),  
#             cata=as.factor(ifelse(runif(20)>0.5, "a", "b")), 
#             catb=as.character(ifelse(runif(20)>0.5, "d", "e")), 
#             stringsAsFactors=FALSE)
# res1 <- gen_dist_metric(data=testfr, colname_target="class", use_n_cores=1, n_batches=NULL, dist_type=c("hvdm"))
# res2 <- gen_dist_metric(data=testfr, colname_target="class", use_n_cores=2, n_batches=NULL, dist_type=c("heom"))
# res3 <- gen_dist_metric(data=testfr, colname_target="class", use_n_cores=2, n_batches=8, dist_type=c("hvdm"))
# res4 <- gen_dist_metric(data=testfr, colname_target="class", use_n_cores=2, n_batches=8, dist_type=c("heom"))
# identical(res1, res3)
# identical(res2, res4)